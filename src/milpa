#!/usr/bin/env bash
# MILPA_PATH contains all known milpa repositories
# Repositories are folders that contain a .milpa directory within
# set to MILPA_ROOT if empty, otherwise prepend $MILPA_ROOT:
MILPA_PATH="${MILPA_PATH+$MILPA_ROOT:}${MILPA_PATH:-$MILPA_ROOT}"
# if the current working dir contains a .milpa folder, add that to the path as well
_pwd="$(pwd)"
[[ -d ".milpa" ]] && [[ ! "$MILPA_PATH" =~ :?$_pwd:? ]] && MILPA_PATH="$MILPA_PATH:$_pwd"
export MILPA_PATH
# create an array from this path
IFS=: read -ra MILPA_PATH_ARR <<<"$MILPA_PATH"
export MILPA_PATH_ARR
# bash is fine and all, but we need a little helper to run argument parsing for us
export MILPA_HELPER="${MILPA_HELPER:-$MILPA_ROOT/src/milpa-helper}"

[[ $1 == "__complete" ]] && exec "$MILPA_HELPER" "$@"

function load_milpa_util () {
  # shell scripts can call load_milpa_util to load utils within the $MILPA_PATH
  # TODO: maybe bump $MILPA_COMMAND_PACKAGE up in the path?
  local env_name
  for util_name in "$@"; do
    env_name="_MILPA_UTIL_${util_name//-/_}"
    if [[ "${!env_name}" == "1" ]]; then
      # util already loaded
      continue
    fi

    for pkg in $MILPA_PATH_ARR ; do
      util_path="${pkg}/.milpa/util/$util_name.sh"
      if [[ -f "$util_path" ]]; then
        set -o allexport
        # shellcheck disable=1090
        source "$util_path"
        set +o allexport
        export "${env_name?}=1"
        break
      fi
    done

    if [[ "${!env_name}" != "1" ]]; then
      # util not found
      >&2 echo "Missing util named $util_name"
    exit 2
    fi
  done
}

load_milpa_util log
function _fail () {
  _log error "$*"
  exit 2
}

mhout=$(mktemp -t "mhout.XXX")
mherr=$(mktemp -t "mherr.XXX")
trap 'rm -rf $mhout $mherr' ERR EXIT TERM

"$MILPA_HELPER" "$@" >"$mhout" 2>"$mherr" || {
  exitCode=$?

  if [[ "$exitCode" == 42 ]]; then
    # help requested
    cat "$mhout"
    rm -rf "$mhout" "$mherr"
    exit
  fi

  error_message=""
  while read -r line; do
    if [[ "$line" = "Error: "* ]]; then
      error_message+="${line/Error: /}"
      continue
    fi
    >&2 echo "$line"
  done < <(cat "$mherr" "$mhout")
  rm -rf "$mhout" "$mherr"


  [[ "$error_message" != "" ]] && _log error "$error_message"
  exit $exitCode
}

# load parsed arguments and MILPA_ environment variables
eval "$(cat "$mhout")" || _fail "Failed setting command environment"

[[ "${MILPA_VERBOSE:-$MILPA_OPT_VERBOSE}" == "true" ]] && export MILPA_VERBOSE="true"
[[ "$MILPA_DEBUG" == 1 ]] && _log debug "milpa-helper output: $(cat "$mherr")"
_log debug "running <$MILPA_COMMAND_NAME from> <$MILPA_COMMAND_PATH> with arguments <${*}>"
_log debug "milpa environment:"$'\n'"$(env | grep ^MILPA | sort)"

rm -rf "$mhout" "$mherr"

if [[ -f "$MILPA_COMMAND_PACKAGE/.milpa/hooks/before-run.sh" ]]; then
  set -o allexport
  # shellcheck disable=1091
  source "$MILPA_COMMAND_PACKAGE/.milpa/hooks/before-run.sh"
  set +o allexport
fi

case "$MILPA_COMMAND_KIND" in
  exec) exec "$MILPA_COMMAND_PATH" "$@" ;;
  source)
    # shellcheck disable=1090
    source "$MILPA_COMMAND_PATH";;
  *) _log warning "Unsure how to run $MILPA_COMMAND_NAME. Found $MILPA_COMMAND_PATH, but it is neither a .sh file nor executable" && _fail "Unable to continue running sub-command."
esac
